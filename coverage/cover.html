
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cyworld8x/go-postgres-kubernetes-grpc/api/handler/user.go (69.4%)</option>
				
				<option value="file1">github.com/cyworld8x/go-postgres-kubernetes-grpc/api/main.go (77.8%)</option>
				
				<option value="file2">github.com/cyworld8x/go-postgres-kubernetes-grpc/api/middleware/authorization.go (100.0%)</option>
				
				<option value="file3">github.com/cyworld8x/go-postgres-kubernetes-grpc/api/test/server.go (0.0%)</option>
				
				<option value="file4">github.com/cyworld8x/go-postgres-kubernetes-grpc/db/mock/store.go (18.3%)</option>
				
				<option value="file5">github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc/db.go (50.0%)</option>
				
				<option value="file6">github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc/execTransaction.go (60.0%)</option>
				
				<option value="file7">github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc/follow.sql.go (21.1%)</option>
				
				<option value="file8">github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc/store.go (100.0%)</option>
				
				<option value="file9">github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc/tx_follow.go (87.5%)</option>
				
				<option value="file10">github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc/user.sql.go (13.8%)</option>
				
				<option value="file11">github.com/cyworld8x/go-postgres-kubernetes-grpc/main.go (0.0%)</option>
				
				<option value="file12">github.com/cyworld8x/go-postgres-kubernetes-grpc/pkg/paseto/maker.go (75.0%)</option>
				
				<option value="file13">github.com/cyworld8x/go-postgres-kubernetes-grpc/pkg/paseto/payload.go (72.7%)</option>
				
				<option value="file14">github.com/cyworld8x/go-postgres-kubernetes-grpc/usecase/user/mock/user.go (0.0%)</option>
				
				<option value="file15">github.com/cyworld8x/go-postgres-kubernetes-grpc/usecase/user/service.go (62.5%)</option>
				
				<option value="file16">github.com/cyworld8x/go-postgres-kubernetes-grpc/util/configuration.go (88.9%)</option>
				
				<option value="file17">github.com/cyworld8x/go-postgres-kubernetes-grpc/util/password.go (80.0%)</option>
				
				<option value="file18">github.com/cyworld8x/go-postgres-kubernetes-grpc/util/random.go (80.0%)</option>
				
				<option value="file19">github.com/cyworld8x/go-postgres-kubernetes-grpc/util/randomuser.go (60.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handler

import (
        "net/http"
        "strconv"
        "time"

        "github.com/cyworld8x/go-postgres-kubernetes-grpc/api/middleware"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/api/presenter"
        db "github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/pkg/paseto"
        user "github.com/cyworld8x/go-postgres-kubernetes-grpc/usecase/user"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/util"
        "github.com/gin-gonic/gin"
)

type createUserRequest struct {
        Username string `json:"username"`
        Email    string `json:"email"`
        Fullname string `json:"fullname"`
        Password string `json:"password"`
        Role     string `json:"role"`
}

type loginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type loginResponse struct {
        ID       int32  `json:"id"`
        Username string `json:"username"`
        Token    string `json:"token"`
        Email    string `json:"email"`
}

func newUserResponse(user db.User) presenter.User <span class="cov8" title="1">{
        return presenter.User{
                ID:        user.ID,
                Username:  user.Username.String,
                Email:     user.Email.String,
                Fullname:  user.Fullname.String,
                Password:  user.Password.String,
                Role:      user.Role.String,
                CreatedAt: user.CreatedAt.Time,
        }
}</span>

func userLoginResponse(user db.User) loginResponse <span class="cov8" title="1">{
        return loginResponse{
                ID:       user.ID,
                Username: user.Username.String,
                Email:    user.Email.String,
        }
}</span>

func MakeUserHandler(router *gin.Engine, service user.UseCase) <span class="cov8" title="1">{
        router.POST("/user", createUser(service))
        router.POST("/login", getLogin(service))
        pasetoMaker, _ := paseto.NewPasetoMaker()
        authRoutes := router.Group("/").Use(middleware.AuthMiddleware(pasetoMaker))
        authRoutes.GET("/user/:id", getUser(service))
}</span>
func createUser(service user.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        // Add your code logic here
        return gin.HandlerFunc(func(ctx *gin.Context) </span><span class="cov8" title="1">{

                var req createUserRequest
                if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusBadRequest, err)
                        return
                }</span>
                <span class="cov8" title="1">user, err := service.CreateUser(req.Username, req.Email, req.Fullname, req.Password, req.Role)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusInternalServerError, err)
                        return
                }</span>
                <span class="cov8" title="1">rsp := newUserResponse(user)
                ctx.JSON(http.StatusOK, rsp)</span>
        })
}

func getLogin(service user.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        // Add your code logic here
        return gin.HandlerFunc(func(ctx *gin.Context) </span><span class="cov8" title="1">{
                var req loginRequest
                if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, nil)
                        return
                }</span>

                <span class="cov8" title="1">user, err := service.GetLogin(req.Username)
                if err != nil </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusBadRequest, "User name doesn't match")
                        return
                }</span>

                <span class="cov8" title="1">err = util.CheckPassword(req.Password, user.Password.String)
                if err != nil </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusUnauthorized, "Can't login with user name and password.")
                        return
                }</span>

                <span class="cov8" title="1">rsp := userLoginResponse(user)
                maker, _ := paseto.NewPasetoMaker()
                token, _, err := maker.CreateToken(user.Username.String, time.Hour)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusInternalServerError, err)
                }</span>
                <span class="cov8" title="1">rsp.Token = token
                ctx.JSON(http.StatusOK, rsp)</span>
        })

}

func getUser(service user.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        // Add your code logic here
        return gin.HandlerFunc(func(ctx *gin.Context) </span><span class="cov0" title="0">{

                id, err := strconv.Atoi(ctx.Param("id"))
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, err)
                        return
                }</span>
                <span class="cov0" title="0">user, err := service.GetUser(int32(id))
                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusOK, "User doesn't exist")
                        return
                }</span>
                <span class="cov0" title="0">rsp := newUserResponse(user)
                ctx.JSON(http.StatusOK, rsp)</span>
        })

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        handler "github.com/cyworld8x/go-postgres-kubernetes-grpc/api/handler"

        db "github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/usecase/user"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/util"
        "github.com/gin-gonic/gin"
)

// Server serves HTTP requests for our banking service.
type Server struct {
        store  db.Store
        Router *gin.Engine
}

// NewServer creates a new HTTP server and set up routing.
func NewServer(config util.Configuration, store db.Store) (*Server, error) <span class="cov8" title="1">{

        server := &amp;Server{
                store: store,
        }

        server.setupRouter()
        return server, nil
}</span>

func (server *Server) setupRouter() <span class="cov8" title="1">{
        router := gin.Default()
        userService := user.NewService(server.store)
        handler.MakeUserHandler(router, userService) // Pass userService instead of userService.CreateUser

        // router.POST("/users/login", server.loginUser)
        // router.POST("/tokens/renew_access", server.renewAccessToken)

        // authRoutes := router.Group("/").Use(authMiddleware(server.tokenMaker))
        // authRoutes.POST("/accounts", server.createAccount)
        // authRoutes.GET("/accounts/:id", server.getAccount)
        // authRoutes.GET("/accounts", server.listAccounts)

        // authRoutes.POST("/transfers", server.createTransfer)

        server.Router = router
}</span>

// Start runs the HTTP server on a specific address.
func (server *Server) Start(address string) error <span class="cov0" title="0">{
        return server.Router.Run(address)
}</span>

func errorResponse(err error) gin.H <span class="cov0" title="0">{
        return gin.H{"error": err.Error()}
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "errors"
        "net/http"
        "strings"

        "github.com/cyworld8x/go-postgres-kubernetes-grpc/pkg/paseto"
        "github.com/gin-gonic/gin"
)

func AuthMiddleware(am *paseto.PasetoMaker) gin.HandlerFunc <span class="cov8" title="1">{

        return gin.HandlerFunc(func(ctx *gin.Context) </span><span class="cov8" title="1">{
                authHeader := ctx.GetHeader("Authorization")
                if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="1">{
                        // Return unauthorized status code if the header is missing or invalid
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, errors.New("Unauthorized"))
                        return
                }</span>
                // Get the Authorization header value
                <span class="cov8" title="1">token := strings.TrimPrefix(authHeader, "Bearer ")
                payload, err := am.VerifyToken(token)
                if err != nil </span><span class="cov8" title="1">{
                        ctx.AbortWithStatusJSON(http.StatusUnauthorized, err)
                        return
                }</span>
                <span class="cov8" title="1">ctx.Set("authorization_payload", payload)
                ctx.Next()</span>
        })

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package servertest

import (
        "context"
        "testing"

        api "github.com/cyworld8x/go-postgres-kubernetes-grpc/api"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/util"
        "github.com/jackc/pgx/v5/pgxpool"

        db "github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc"
)

func NewTestServer(t *testing.T) (*api.Server, error) <span class="cov0" title="0">{
        testConfig := util.Configuration{
                DbSource:          "postgresql://postgres:postgres@localhost:20241/socialdb?sslmode=disable",
                HTTPServerAddress: "localhost:8080",
        }
        conn, err := pgxpool.New(context.Background(), testConfig.DbSource)
        testStore := db.NewStore(conn)
        if err == nil </span><span class="cov0" title="0">{
                return api.NewServer(testConfig, testStore)
        }</span>

        <span class="cov0" title="0">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc (interfaces: Store)

// Package mockdb is a generated GoMock package.
package mockdb

import (
        context "context"
        reflect "reflect"

        db "github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc"
        gomock "github.com/golang/mock/gomock"
        pgtype "github.com/jackc/pgx/v5/pgtype"
)

// MockStore is a mock of Store interface.
type MockStore struct {
        ctrl     *gomock.Controller
        recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
        mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore <span class="cov8" title="1">{
        mock := &amp;MockStore{ctrl: ctrl}
        mock.recorder = &amp;MockStoreMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockStore) CreateUser(arg0 context.Context, arg1 db.CreateUserParams) (db.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockStoreMockRecorder) CreateUser(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockStore)(nil).CreateUser), arg0, arg1)
}</span>

// DeleteUser mocks base method.
func (m *MockStore) DeleteUser(arg0 context.Context, arg1 int32) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockStoreMockRecorder) DeleteUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockStore)(nil).DeleteUser), arg0, arg1)
}</span>

// FollowTx mocks base method.
func (m *MockStore) FollowTx(arg0 context.Context, arg1 db.FollowsTransParam) (db.FollowsTransResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FollowTx", arg0, arg1)
        ret0, _ := ret[0].(db.FollowsTransResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FollowTx indicates an expected call of FollowTx.
func (mr *MockStoreMockRecorder) FollowTx(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FollowTx", reflect.TypeOf((*MockStore)(nil).FollowTx), arg0, arg1)
}</span>

// FollowUser mocks base method.
func (m *MockStore) FollowUser(arg0 context.Context, arg1 db.FollowUserParams) (db.Follow, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FollowUser", arg0, arg1)
        ret0, _ := ret[0].(db.Follow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FollowUser indicates an expected call of FollowUser.
func (mr *MockStoreMockRecorder) FollowUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FollowUser", reflect.TypeOf((*MockStore)(nil).FollowUser), arg0, arg1)
}</span>

// GetFollowers mocks base method.
func (m *MockStore) GetFollowers(arg0 context.Context, arg1 int32) ([]db.Follow, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFollowers", arg0, arg1)
        ret0, _ := ret[0].([]db.Follow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFollowers indicates an expected call of GetFollowers.
func (mr *MockStoreMockRecorder) GetFollowers(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFollowers", reflect.TypeOf((*MockStore)(nil).GetFollowers), arg0, arg1)
}</span>

// GetLogin mocks base method.
func (m *MockStore) GetLogin(arg0 context.Context, arg1 pgtype.Text) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLogin", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLogin indicates an expected call of GetLogin.
func (mr *MockStoreMockRecorder) GetLogin(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogin", reflect.TypeOf((*MockStore)(nil).GetLogin), arg0, arg1)
}</span>

// GetUser mocks base method.
func (m *MockStore) GetUser(arg0 context.Context, arg1 int32) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockStoreMockRecorder) GetUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockStore)(nil).GetUser), arg0, arg1)
}</span>

// ListUsers mocks base method.
func (m *MockStore) ListUsers(arg0 context.Context) ([]db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListUsers", arg0)
        ret0, _ := ret[0].([]db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListUsers indicates an expected call of ListUsers.
func (mr *MockStoreMockRecorder) ListUsers(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*MockStore)(nil).ListUsers), arg0)
}</span>

// UnfollowUser mocks base method.
func (m *MockStore) UnfollowUser(arg0 context.Context, arg1 db.UnfollowUserParams) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UnfollowUser", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UnfollowUser indicates an expected call of UnfollowUser.
func (mr *MockStoreMockRecorder) UnfollowUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnfollowUser", reflect.TypeOf((*MockStore)(nil).UnfollowUser), arg0, arg1)
}</span>

// UpdateUser mocks base method.
func (m *MockStore) UpdateUser(arg0 context.Context, arg1 db.UpdateUserParams) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockStoreMockRecorder) UpdateUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockStore)(nil).UpdateUser), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package db

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package db

import (
        "context"
        "fmt"
)

func (store *SQLStore) execTx(ctx context.Context, fn func(*Queries) error) error <span class="cov8" title="1">{
        tx, err := store.connPool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">q := New(tx)

        err = fn(q)
        if err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: follow.sql

package db

import (
        "context"
)

const followUser = `-- name: FollowUser :one
INSERT INTO follows (
  following_user_id, followed_user_id
) VALUES (
  $1, $2
)
RETURNING following_user_id, followed_user_id, created_at
`

type FollowUserParams struct {
        FollowingUserID int32 `json:"following_user_id"`
        FollowedUserID  int32 `json:"followed_user_id"`
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (Follow, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, followUser, arg.FollowingUserID, arg.FollowedUserID)
        var i Follow
        err := row.Scan(&amp;i.FollowingUserID, &amp;i.FollowedUserID, &amp;i.CreatedAt)
        return i, err
}</span>

const getFollowers = `-- name: GetFollowers :many
SELECT following_user_id, followed_user_id, created_at FROM follows
WHERE followed_user_id = $1 LIMIT 1
`

func (q *Queries) GetFollowers(ctx context.Context, followedUserID int32) ([]Follow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getFollowers, followedUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Follow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Follow
                if err := rows.Scan(&amp;i.FollowingUserID, &amp;i.FollowedUserID, &amp;i.CreatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const unfollowUser = `-- name: UnfollowUser :exec
DELETE FROM follows
WHERE followed_user_id = $1 AND following_user_id = $2
`

type UnfollowUserParams struct {
        FollowedUserID  int32 `json:"followed_user_id"`
        FollowingUserID int32 `json:"following_user_id"`
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, unfollowUser, arg.FollowedUserID, arg.FollowingUserID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgxpool"
)

type Store interface {
        Querier
        FollowTx(ctx context.Context, arg FollowsTransParam) (FollowsTransResult, error)
}

// Store provides all functions to execute do queries and transactions
type SQLStore struct {
        connPool *pgxpool.Pool
        *Queries
}

// Newstere creates a new Store
func NewStore(connPool *pgxpool.Pool) Store <span class="cov8" title="1">{
        return &amp;SQLStore{
                connPool: connPool,
                Queries:  New(connPool),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package db

import "context"

type FollowsTransParam struct {
        FollowUserParams
        AfterFollow func(follow Follow) error
}

type FollowsTransResult struct {
        Follow Follow `json:"follow"`
}

func (store *SQLStore) FollowTx(ctx context.Context, arg FollowsTransParam) (FollowsTransResult, error) <span class="cov8" title="1">{
        var result FollowsTransResult

        err := store.execTx(ctx, func(q *Queries) error </span><span class="cov8" title="1">{
                var err error

                result.Follow, err = q.FollowUser(ctx, arg.FollowUserParams)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return result, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: user.sql

package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  username, email, fullname, password, role
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, username, email, fullname, password, role, created_at
`

type CreateUserParams struct {
        Username pgtype.Text `json:"username"`
        Email    pgtype.Text `json:"email"`
        Fullname pgtype.Text `json:"fullname"`
        Password pgtype.Text `json:"password"`
        Role     pgtype.Text `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createUser,
                arg.Username,
                arg.Email,
                arg.Fullname,
                arg.Password,
                arg.Role,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.Fullname,
                &amp;i.Password,
                &amp;i.Role,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteUser, id)
        return err
}</span>

const getLogin = `-- name: GetLogin :one
SELECT id, username, email, fullname, password, role, created_at FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetLogin(ctx context.Context, username pgtype.Text) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getLogin, username)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.Fullname,
                &amp;i.Password,
                &amp;i.Role,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getUser = `-- name: GetUser :one
SELECT id, username, email, fullname, password, role, created_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUser, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.Fullname,
                &amp;i.Password,
                &amp;i.Role,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, fullname, password, role, created_at FROM users
ORDER BY username
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listUsers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []User{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i User
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Username,
                        &amp;i.Email,
                        &amp;i.Fullname,
                        &amp;i.Password,
                        &amp;i.Role,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
  set username = $2,
  role = $3
WHERE id = $1
`

type UpdateUserParams struct {
        ID       int32       `json:"id"`
        Username pgtype.Text `json:"username"`
        Role     pgtype.Text `json:"role"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateUser, arg.ID, arg.Username, arg.Role)
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "context"
        "log"

        "github.com/cyworld8x/go-postgres-kubernetes-grpc/api"
        db "github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/util"
        "github.com/jackc/pgx/v5/pgxpool"
)

func main() <span class="cov0" title="0">{
        config, err := util.LoadConfiguration(".")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("can not load env configuration:", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Load env configuration %s", config)
        conn, err := pgxpool.New(context.Background(), config.DbSource)
        store := db.NewStore(conn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("can not connect to db:", err)
        }</span>

        <span class="cov0" title="0">runGinServer(config, store)</span>
}

func runGinServer(config util.Configuration, store db.Store) <span class="cov0" title="0">{
        server, err := api.NewServer(config, store)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot create server", err)
        }</span>

        <span class="cov0" title="0">err = server.Start(config.HTTPServerAddress)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot start server", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package paseto

import (
        "errors"
        "fmt"
        "time"

        "github.com/o1egl/paseto"
)

var (
        ErrInvalidToken = errors.New("token is invalid")
        ErrExpiredToken = errors.New("token has expired")
)

type PasetoMaker struct {
        secretKey []byte
}

func NewPasetoMaker() (*PasetoMaker, error) <span class="cov8" title="1">{
        symmetricKey := "YELLOW SUBMARINE, BLACK WIZARDRY"
        if len(symmetricKey) != 32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key size: must be exactly 32 characters")
        }</span>
        <span class="cov8" title="1">return &amp;PasetoMaker{
                secretKey: []byte(symmetricKey),
        }, nil</span>
}

func (pm *PasetoMaker) CreateToken(username string, duration time.Duration) (string, *Payload, error) <span class="cov8" title="1">{
        payload, err := NewPayload(username, duration)
        if err != nil </span><span class="cov0" title="0">{
                return "", payload, err
        }</span>

        // Encrypt and sign the token
        <span class="cov8" title="1">encrypter := paseto.NewV2()
        token, err := encrypter.Encrypt(pm.secretKey, payload, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", payload, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return token, payload, nil</span>
}

func (pm *PasetoMaker) VerifyToken(token string) (*Payload, error) <span class="cov8" title="1">{
        // Create a new Paseto token
        payload := &amp;Payload{}

        // Decrypt and verify the token
        decrypter := paseto.NewV2()
        err := decrypter.Decrypt(token, pm.secretKey, payload, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if payload.IsValid() </span><span class="cov8" title="1">{
                return payload, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrExpiredToken</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package paseto

import (
        "time"

        "github.com/google/uuid"
)

type Payload struct {
        ID        uuid.UUID `json:"id"`
        Username  string    `json:"username"`
        Issuer    string    `json:"issuer,omitempty"`
        Audience  string    `json:"audience,omitempty"`
        ExpiredAt time.Time `json:"expired_at ,omitempty"`
        IssuedAt  time.Time `json:"issued_at,omitempty"`
}

func (p *Payload) IsValid() bool <span class="cov8" title="1">{
        now := time.Now().UTC()

        if now.Before(p.IssuedAt) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if now.After(p.ExpiredAt) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func NewPayload(username string, duration time.Duration) (*Payload, error) <span class="cov8" title="1">{
        tokenID, err := uuid.NewRandom()
        now := time.Now().UTC()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Payload{
                ID:        tokenID,
                Issuer:    "issuer",
                Audience:  "audience",
                Username:  username,
                ExpiredAt: now.Add(duration),
                IssuedAt:  now,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: usecase/user/interface.go

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        db "github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc"
        gomock "github.com/golang/mock/gomock"
        pgtype "github.com/jackc/pgx/v5/pgtype"
)

// MockReader is a mock of Reader interface.
type MockReader struct {
        ctrl     *gomock.Controller
        recorder *MockReaderMockRecorder
}

// MockReaderMockRecorder is the mock recorder for MockReader.
type MockReaderMockRecorder struct {
        mock *MockReader
}

// NewMockReader creates a new mock instance.
func NewMockReader(ctrl *gomock.Controller) *MockReader <span class="cov0" title="0">{
        mock := &amp;MockReader{ctrl: ctrl}
        mock.recorder = &amp;MockReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReader) EXPECT() *MockReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DeleteUser mocks base method.
func (m *MockReader) DeleteUser(ctx context.Context, id int32) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockReaderMockRecorder) DeleteUser(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockReader)(nil).DeleteUser), ctx, id)
}</span>

// GetLogin mocks base method.
func (m *MockReader) GetLogin(ctx context.Context, username pgtype.Text) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLogin", ctx, username)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLogin indicates an expected call of GetLogin.
func (mr *MockReaderMockRecorder) GetLogin(ctx, username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogin", reflect.TypeOf((*MockReader)(nil).GetLogin), ctx, username)
}</span>

// GetUser mocks base method.
func (m *MockReader) GetUser(ctx context.Context, id int32) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", ctx, id)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockReaderMockRecorder) GetUser(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockReader)(nil).GetUser), ctx, id)
}</span>

// ListUsers mocks base method.
func (m *MockReader) ListUsers(ctx context.Context) ([]db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListUsers", ctx)
        ret0, _ := ret[0].([]db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListUsers indicates an expected call of ListUsers.
func (mr *MockReaderMockRecorder) ListUsers(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*MockReader)(nil).ListUsers), ctx)
}</span>

// MockWriter is a mock of Writer interface.
type MockWriter struct {
        ctrl     *gomock.Controller
        recorder *MockWriterMockRecorder
}

// MockWriterMockRecorder is the mock recorder for MockWriter.
type MockWriterMockRecorder struct {
        mock *MockWriter
}

// NewMockWriter creates a new mock instance.
func NewMockWriter(ctrl *gomock.Controller) *MockWriter <span class="cov0" title="0">{
        mock := &amp;MockWriter{ctrl: ctrl}
        mock.recorder = &amp;MockWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWriter) EXPECT() *MockWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockWriter) CreateUser(ctx context.Context, arg db.CreateUserParams) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, arg)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockWriterMockRecorder) CreateUser(ctx, arg interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockWriter)(nil).CreateUser), ctx, arg)
}</span>

// DeleteUser mocks base method.
func (m *MockWriter) DeleteUser(ctx context.Context, id int32) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockWriterMockRecorder) DeleteUser(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockWriter)(nil).DeleteUser), ctx, id)
}</span>

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov0" title="0">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockRepository) CreateUser(ctx context.Context, arg db.CreateUserParams) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, arg)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockRepositoryMockRecorder) CreateUser(ctx, arg interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockRepository)(nil).CreateUser), ctx, arg)
}</span>

// DeleteUser mocks base method.
func (m *MockRepository) DeleteUser(ctx context.Context, id int32) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockRepositoryMockRecorder) DeleteUser(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockRepository)(nil).DeleteUser), ctx, id)
}</span>

// GetLogin mocks base method.
func (m *MockRepository) GetLogin(ctx context.Context, username pgtype.Text) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLogin", ctx, username)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLogin indicates an expected call of GetLogin.
func (mr *MockRepositoryMockRecorder) GetLogin(ctx, username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogin", reflect.TypeOf((*MockRepository)(nil).GetLogin), ctx, username)
}</span>

// GetUser mocks base method.
func (m *MockRepository) GetUser(ctx context.Context, id int32) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", ctx, id)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockRepositoryMockRecorder) GetUser(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockRepository)(nil).GetUser), ctx, id)
}</span>

// ListUsers mocks base method.
func (m *MockRepository) ListUsers(ctx context.Context) ([]db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListUsers", ctx)
        ret0, _ := ret[0].([]db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListUsers indicates an expected call of ListUsers.
func (mr *MockRepositoryMockRecorder) ListUsers(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*MockRepository)(nil).ListUsers), ctx)
}</span>

// MockUseCase is a mock of UseCase interface.
type MockUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockUseCaseMockRecorder
}

// MockUseCaseMockRecorder is the mock recorder for MockUseCase.
type MockUseCaseMockRecorder struct {
        mock *MockUseCase
}

// NewMockUseCase creates a new mock instance.
func NewMockUseCase(ctrl *gomock.Controller) *MockUseCase <span class="cov0" title="0">{
        mock := &amp;MockUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUseCase) EXPECT() *MockUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUseCase) CreateUser(username, email, fullname, password, role string) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", username, email, fullname, password, role)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUseCaseMockRecorder) CreateUser(username, email, fullname, password, role interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUseCase)(nil).CreateUser), username, email, fullname, password, role)
}</span>

// GetLogin mocks base method.
func (m *MockUseCase) GetLogin(username string) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLogin", username)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLogin indicates an expected call of GetLogin.
func (mr *MockUseCaseMockRecorder) GetLogin(username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogin", reflect.TypeOf((*MockUseCase)(nil).GetLogin), username)
}</span>

// GetUser mocks base method.
func (m *MockUseCase) GetUser(Id int32) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", Id)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockUseCaseMockRecorder) GetUser(Id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockUseCase)(nil).GetUser), Id)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package user

import (
        "context"

        db "github.com/cyworld8x/go-postgres-kubernetes-grpc/db/sqlc"
        "github.com/cyworld8x/go-postgres-kubernetes-grpc/util"

        "github.com/jackc/pgx/v5/pgtype"
)

// Service book usecase
type Service struct {
        repo Repository
}

// NewService create new service
func NewService(r Repository) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: r,
        }
}</span>

// CreateUser create an user
func (s *Service) CreateUser(username, email, fullname, password, role string) (db.User, error) <span class="cov8" title="1">{

        pwd, err := util.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return db.User{}, err
        }</span>
        <span class="cov8" title="1">user := db.CreateUserParams{
                Username: pgtype.Text{String: username, Valid: true},
                Email:    pgtype.Text{String: email, Valid: true},
                Fullname: pgtype.Text{String: fullname, Valid: true},
                Password: pgtype.Text{String: pwd, Valid: true},
                Role:     pgtype.Text{String: role, Valid: true},
        }
        return s.repo.CreateUser(context.Background(), user)</span>
}

// GetUser get user
func (s *Service) GetUser(id int32) (db.User, error) <span class="cov0" title="0">{
        return s.repo.GetUser(context.Background(), id)
}</span>

// GetLogin get Login
func (s *Service) GetLogin(username string) (db.User, error) <span class="cov0" title="0">{
        return s.repo.GetLogin(context.Background(), pgtype.Text{String: username, Valid: true})
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package util

import "github.com/spf13/viper"

type Configuration struct {
        DbDriver          string `mapstructure:"DB_DRIVER"`
        DbSource          string `mapstructure:"DB_SOURCE"`
        HTTPServerAddress string `mapstructure:"HTTP_SERVER_ADDRESS"`
}

// Configuration readling configuration from file
func LoadConfiguration(path string) (config Configuration, err error) <span class="cov8" title="1">{
        viper.AddConfigPath(path)
        viper.SetConfigName("app")
        viper.SetConfigType("env")
        viper.AutomaticEnv()

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = viper.Unmarshal(&amp;config)
        return</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package util

import (
        "fmt"

        "golang.org/x/crypto/bcrypt"
)

// HashPassword returns the bcrypt hash of the password
func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash password: %w", err)
        }</span>
        <span class="cov8" title="1">return string(hashedPassword), nil</span>
}

// CheckPassword checks if the provided password is correct or not
func CheckPassword(password string, hashedPassword string) error <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package util

import "math/rand"

func GenAnUser() User <span class="cov8" title="1">{
        users, err := Generate(&amp;QueryConfig{1, ""})
        if err == nil &amp;&amp; len(users) &gt; 0 </span><span class="cov8" title="1">{
                return users[0]
        }</span>
        <span class="cov0" title="0">return User{}</span>
}

// RandomMoney generates a random amount of money
func RandomId() int32 <span class="cov8" title="1">{
        return rand.Int31()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package util

import (
        "encoding/json"
        "io"
        "log"
        "net/http"
        "net/url"
        "strconv"
)

type User struct {
        Email string `json:"email"`
        Name  struct {
                Title string `json:"title"`
                First string `json:"first"`
                Last  string `json:"last"`
        } `json:"name"`
        Login struct {
                UserName string `json:"username"`
                Password string `json:"password"`
        } `json:"login"`
}

type Info struct {
        Seed    string `json:"seed"`
        Results int    `json:"results"`
        Page    int    `json:"page"`
        Version string `json:"version"`
}

type JsonRandomUser struct {
        Results []User `json:"results"`
        Info    Info   `json:"info"`
}

const BASE_URI_RANDOM_USER_API = "https://randomuser.me/api/"

const (
        MAX_RESULTS = 5000
        MIN_RESULTS = 1
)

const (
        KEY_RESULTS = "results"
        KEY_SEED    = "seed"
)

type QueryConfig struct {
        MaxResults int
        Seed       string
}

func NewQueryConfig() *QueryConfig <span class="cov0" title="0">{
        return &amp;QueryConfig{MIN_RESULTS, ""}
}</span>

func (c *QueryConfig) encode(u *url.URL) <span class="cov8" title="1">{
        q := u.Query()

        if c.MaxResults &lt; 0 </span><span class="cov0" title="0">{
                c.MaxResults = MIN_RESULTS
        }</span> else<span class="cov8" title="1"> if c.MaxResults &gt; MAX_RESULTS </span><span class="cov0" title="0">{
                c.MaxResults = MAX_RESULTS
        }</span>

        <span class="cov8" title="1">q.Set(KEY_RESULTS, strconv.Itoa(c.MaxResults))

        u.RawQuery = q.Encode()</span>
}

func Generate(c *QueryConfig) ([]User, error) <span class="cov8" title="1">{
        u, err := url.Parse(BASE_URI_RANDOM_USER_API)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">c.encode(u)

        response, err := http.Get(BASE_URI_RANDOM_USER_API + "?" + u.Query().Encode())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()

        rawBytes, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">var jsonRandomUser JsonRandomUser
        err = json.Unmarshal(rawBytes, &amp;jsonRandomUser)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return jsonRandomUser.Results, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
